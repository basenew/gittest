#include "complex.h"
#include <math.h>
#include <rtthread.h>
const float radToTanVector[] ={
 0.0f,
0.010000333f,
0.020002667f,
0.030009003f,
0.040021347f,
0.050041708f,
0.060072104f,
0.070114558f,
0.080171105f,
0.09024379f,
0.100334672f,
0.110445825f,
0.120579337f,
0.130737318f,
0.140921895f,
0.151135218f,
0.161379461f,
0.171656822f,
0.181969529f,
0.192319838f,
0.202710036f,
0.213142444f,
0.223619422f,
0.234143362f,
0.244716703f,
0.255341921f,
0.266021542f,
0.276758136f,
0.287554326f,
0.298412787f,
0.30933625f,
0.320327505f,
0.331389405f,
0.342524868f,
0.353736878f,
0.365028495f,
0.376402852f,
0.387863162f,
0.399412721f,
0.411054915f,
0.422793219f,
0.434631205f,
0.446572546f,
0.458621023f,
0.470780527f,
0.483055066f,
0.495448769f,
0.507965897f,
0.520610844f,
0.533388147f,
0.54630249f,
0.559358716f,
0.57256183f,
0.585917013f,
0.599429623f,
0.613105213f,
0.626949535f,
0.640968552f,
0.655168449f,
0.669555646f,
0.684136808f,
0.698918862f,
0.713909007f,
0.729114729f,
0.744543822f,
0.760204399f,
0.776104913f,
0.792254175f,
0.808661375f,
0.825336105f,
0.84228838f,
0.859528665f,
0.8770679f,
0.894917529f,
0.913089533f,
0.93159646f,
0.950451461f,
0.969668328f,
0.989261537f,
1.009246288f,
1.029638557f
};

const float tanToRadVector[] ={
 0.0f,
0.009999667f,
0.019997334f,
0.029991005f,
0.039978687f,
0.049958396f,
0.059928155f,
0.069886002f,
0.079829986f,
0.089758174f,
0.099668652f,
0.109559527f,
0.119428926f,
0.129275004f,
0.139095941f,
0.148889948f,
0.158655262f,
0.168390157f,
0.178092938f,
0.187761947f,
0.19739556f,
0.206992194f,
0.216550305f,
0.226068388f,
0.235544981f,
0.244978663f,
0.254368059f,
0.263711834f,
0.273008703f,
0.282257422f,
0.291456794f,
0.30060567f,
0.309702945f,
0.31874756f,
0.327738507f,
0.336674819f,
0.345555581f,
0.354379919f,
0.36314701f,
0.371856074f,
0.380506377f,
0.389097231f,
0.397627992f,
0.406098058f,
0.414506875f,
0.422853926f,
0.431138741f,
0.439360887f,
0.447519975f,
0.455615653f,
0.463647609f,
0.471615568f,
0.479519292f,
0.48735858f,
0.495133263f,
0.502843211f,
0.510488322f,
0.518068528f,
0.525583794f,
0.53303411f,
0.5404195f,
0.547740014f,
0.554995727f,
0.562186744f,
0.569313191f,
0.576375221f,
0.583373007f,
0.590306747f,
0.597176658f,
0.603982978f,
0.610725964f,
0.617405892f,
0.624023053f,
0.630577757f,
0.637070329f,
0.643501109f,
0.649870449f,
0.656178718f,
0.662426294f,
0.668613568f,
0.674740942f,
0.680808829f,
0.68681765f,
0.692767835f,
0.698659825f,
0.704494064f,
0.710271007f,
0.715991114f,
0.721654851f,
0.727262688f,
0.732815102f,
0.738312573f,
0.743755584f,
0.749144625f,
0.754480184f,
0.759762755f,
0.764992833f,
0.770170914f,
0.775297497f,
0.78037308f,
0.785398163f,
0.790373247f,
0.79529883f
};

const float sinVector[] = {
0.0f,
0.017452406f,
0.034899497f,
0.052335956f,
0.069756474f,
0.087155743f,
0.104528463f,
0.121869343f,
0.139173101f,
0.156434465f,
0.173648178f,
0.190808995f,
0.207911691f,
0.224951054f,
0.241921896f,
0.258819045f,
0.275637356f,
0.292371705f,
0.309016994f,
0.325568154f,
0.342020143f,
0.35836795f,
0.374606593f,
0.390731128f,
0.406736643f,
0.422618262f,
0.438371147f,
0.4539905f,
0.469471563f,
0.48480962f,
0.5f,
0.515038075f,
0.529919264f,
0.544639035f,
0.559192903f,
0.573576436f,
0.587785252f,
0.601815023f,
0.615661475f,
0.629320391f,
0.64278761f,
0.656059029f,
0.669130606f,
0.68199836f,
0.69465837f,
0.707106781f,
0.7193398f,
0.731353702f,
0.743144825f,
0.75470958f,
0.766044443f,
0.777145961f,
0.788010754f,
0.79863551f,
0.809016994f,
0.819152044f,
0.829037573f,
0.838670568f,
0.848048096f,
0.857167301f,
0.866025404f,
0.874619707f,
0.882947593f,
0.891006524f,
0.898794046f,
0.906307787f,
0.913545458f,
0.920504853f,
0.927183855f,
0.933580426f,
0.939692621f,
0.945518576f,
0.951056516f,
0.956304756f,
0.961261696f,
0.965925826f,
0.970295726f,
0.974370065f,
0.978147601f,
0.981627183f,
0.984807753f,
0.987688341f,
0.990268069f,
0.992546152f,
0.994521895f,
0.996194698f,
0.99756405f,
0.998629535f,
0.999390827f,
0.999847695f,
1    
};

const float cosVector[] ={
1.0f,
0.999847695f,
0.999390827f,
0.998629535f,
0.99756405f,
0.996194698f,
0.994521895f,
0.992546152f,
0.990268069f,
0.987688341f,
0.984807753f,
0.981627183f,
0.978147601f,
0.974370065f,
0.970295726f,
0.965925826f,
0.961261696f,
0.956304756f,
0.951056516f,
0.945518576f,
0.939692621f,
0.933580426f,
0.927183855f,
0.920504853f,
0.913545458f,
0.906307787f,
0.898794046f,
0.891006524f,
0.882947593f,
0.874619707f,
0.866025404f,
0.857167301f,
0.848048096f,
0.838670568f,
0.829037573f,
0.819152044f,
0.809016994f,
0.79863551f,
0.788010754f,
0.777145961f,
0.766044443f,
0.75470958f,
0.743144825f,
0.731353702f,
0.7193398f,
0.707106781f,
0.69465837f,
0.68199836f,
0.669130606f,
0.656059029f,
0.64278761f,
0.629320391f,
0.615661475f,
0.601815023f,
0.587785252f,
0.573576436f,
0.559192903f,
0.544639035f,
0.529919264f,
0.515038075f,
0.5f,
0.48480962f,
0.469471563f,
0.4539905f,
0.438371147f,
0.422618262f,
0.406736643f,
0.390731128f,
0.374606593f,
0.35836795f,
0.342020143f,
0.325568154f,
0.309016994f,
0.292371705f,
0.275637356f,
0.258819045f,
0.241921896f,
0.224951054f,
0.207911691f,
0.190808995f,
0.173648178f,
0.156434465f,
0.139173101f,
0.121869343f,
0.104528463f,
0.087155743f,
0.069756474f,
0.052335956f,
0.034899497f,
0.017452406f,
0.0f   
};

const float sqrtVector[] = {
0.0f,
0.316227766f,
0.447213595f,
0.547722558f,
0.632455532f,
0.707106781f,
0.774596669f,
0.836660027f,
0.894427191f,
0.948683298f,
1.0f,
1.048808848f,
1.095445115f,
1.140175425f,
1.183215957f,
1.224744871f,
1.264911064f,
1.303840481f,
1.341640786f,
1.378404875f,
1.414213562f,
1.449137675f,
1.483239697f,
1.516575089f,
1.549193338f,
1.58113883f,
1.61245155f,
1.643167673f,
1.673320053f,
1.702938637f,
1.732050808f,
1.760681686f,
1.788854382f,
1.816590212f,
1.843908891f,
1.870828693f,
1.897366596f,
1.923538406f,
1.949358869f,
1.974841766f,
2.0f,
2.024845673f,
2.049390153f,
2.073644135f,
2.097617696f,
2.121320344f,
2.144761059f,
2.167948339f,
2.19089023f,
2.213594362f,
2.236067977f,
2.258317958f,
2.28035085f,
2.302172887f,
2.323790008f,
2.34520788f,
2.366431913f,
2.387467277f,
2.408318916f,
2.42899156f,
2.449489743f,
2.469817807f,
2.48997992f,
2.50998008f,
2.529822128f,
2.549509757f,
2.569046516f,
2.588435821f,
2.607680962f,
2.626785107f,
2.645751311f,
2.664582519f,
2.683281573f,
2.701851217f,
2.720294102f,
2.738612788f,
2.75680975f,
2.774887385f,
2.792848009f,
2.810693865f,
2.828427125f,
2.846049894f,
2.863564213f,
2.880972058f,
2.898275349f,
2.915475947f,
2.93257566f,
2.949576241f,
2.966479395f,
2.983286778f,
3.0f,
3.016620626f,
3.033150178f,
3.049590136f,
3.065941943f,
3.082207001f,
3.098386677f,
3.1144823f,
3.130495168f,
3.146426545f,
3.16227766f
};

COMPLEX_def complexAdd(COMPLEX_def a,COMPLEX_def b){
    COMPLEX_def re;
    re.real = a.real + b.real;
    re.imag = a.imag + b.imag;
    return re;
}

COMPLEX_def complexSub(COMPLEX_def a,COMPLEX_def b){
    COMPLEX_def re;
    re.real = a.real - b.real;
    re.imag = a.imag - b.imag;
    return re;
}

COMPLEX_def complexMul(COMPLEX_def a,COMPLEX_def b){
    COMPLEX_def re;
    re.real = a.real*b.real - a.imag*b.imag;
    re.imag = a.imag*b.real + a.real*b.imag;
    return re;
}

COMPLEX_def complexDiv(COMPLEX_def a,COMPLEX_def b){
    COMPLEX_def re;
    re.real = (a.real*b.real + a.imag*b.imag)/(b.imag*b.imag + b.real*b.real);
    re.imag = (a.imag*b.real - a.real*b.imag)/(b.imag*b.imag + b.real*b.real);
    return re;
}

double getComplexMod(COMPLEX_def a){
    float indexf = (a.real*a.real + a.imag*a.imag);// * DF_SQRT_DIVIDE;
   // int index = (int)indexf;
   // indexf = indexf - index;
    //rt_kprintf("  x:%d y:%d ",(int)(a.real*10000),(int)(a.imag*10000)); 
    
    //if(index > (sizeof(sqrtVector)/sizeof(float)-2)){
   //     rt_kprintf("Complex to sqrt error :%d\r\n",index);
   //     index = 0;
   // }
   // re = sqrtVector[index];
    //reb = sqrtVector[index + 1];
    //re = re + (reb - re) * indexf ; 
    //rt_kprintf("DF_SQRT_DIVIDE :%d\r\n",(int)(indexf *10000));    
    return sqrt(indexf);//re + (reb - re) * indexf ;  
}
double getComplexrad(COMPLEX_def a){
    int q = 0;
    double rad;
    double rad_b;
    double indexf;
    int index;
    if(a.real > 0)
        q|=1;
    if(a.imag > 0)
        q|=2;
    a.real = fabs(a.real);
    a.imag = fabs(a.imag);
    if(a.real > a.imag){
        indexf = DF_RAD_SUB_DIVIDE * a.imag / a.real;
        index = (int)indexf;
        indexf = indexf - index; 
        if(index > (sizeof(tanToRadVector)/sizeof(float)-2))
            rt_kprintf("Complex to radian error:%d\r\n",index);
        rad = tanToRadVector[index];
        rad_b = tanToRadVector[index+1];
        rad = rad + (rad_b - rad) * indexf;
    }else{
         indexf = DF_RAD_SUB_DIVIDE * a.real / a.imag;
        index = (int)indexf;
        indexf = indexf - index;  
        if(index > (sizeof(tanToRadVector)/sizeof(float)-2))
             rt_kprintf("Complex to radian error:%d \r\n",index);
        rad = tanToRadVector[index];
        rad_b = tanToRadVector[index+1];
        rad = rad + (rad_b - rad) * indexf; 
        rad = PI / 2.0f - rad;
    }
    
    
    switch(q){
        case 0:
             rad = rad - PI;
            break;
        case 1:
            rad =  - rad;
            break;
        case 2:
            rad =  PI - rad;
            break;
        case 3:
            break;
        default:
            rt_kprintf("Complex quadrant error3\r\n");
            break;  
    }
    return rad;  
}
COMPLEX_def radModToComplex(double rad,double mod){
    COMPLEX_def re;
    double tem;
    double dI =1.0f;
    double dR = 1.0f;
    float indexf;
    int index;
   // rt_kprintf("rad:%d ang:%d",(int)(rad * 100),(int)(rad * 180.0f /PI)); 
    while(rad > PI)rad-=(2.0f*PI);
    while(rad < (-PI))rad+=(2.0f*PI);
    if(rad < 0.0f){
        rad = -rad;
        dI = -1.0f;
    }
     if(rad > (PI/2)){
        rad = PI - rad;
        dR = -1.0f;
    } 

    indexf = rad * DF_SIN_COS_SUB_DIVIDE/ PI;
    index = (int)indexf;  
    indexf = indexf - index;
    if(index > (sizeof(sinVector)/sizeof(float)-2))
        index = (int)(sizeof(sinVector)/sizeof(float)-2);
     re.imag = sinVector[index];
     tem = sinVector[index+1];
     re.imag = re.imag + (tem - re.imag) * indexf;  
     re.real = cosVector[index];
     tem = cosVector[index+1];
     re.real = re.real + (tem - re.real) * indexf;             
    re.imag = dI * re.imag * mod;
    re.real = dR * re.real * mod;
   // rt_kprintf("rad:%d ang(%d):%d",(int)(rad * 100),index,(int)(rad * 180.0f /PI)); 
   // rt_kprintf("\timg:%d real:%d ",(int)(sinVector[index]*1000),(int)(cosVector[index]*1000)); 
   // rt_kprintf("\timg:%d real:%d ",(int)(re.imag*1000),(int)(re.real*1000)); 

    return re;
}

